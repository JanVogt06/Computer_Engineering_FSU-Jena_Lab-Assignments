\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{graphicx}
\geometry{margin=1.5cm}

\title{Computer Engineering -- Submission due 03.11.2020}
\author{Jan Vogt, Yannik Köllmann - in gleichen Teilen}
\date{\today}

\begin{document}

\maketitle

\section{Gate-level Modeling}

\subsection{My First Module}

\textbf{Tasks}

\begin{enumerate}
\item Implement Eq. (3.1.1) in a module named \texttt{my\_module} using gate-level primitives. Save the code as \texttt{my\_module.sv}.

\begin{verbatim}(siehe ./src/task3.1/my_module.sv)\end{verbatim}

\item Test your implementation using the testbench \texttt{my\_module\_tb}. Save the code as \texttt{my\_module\_tb.sv}. Verify the outputs for all input combinations (see Table 3.1.1).

\begin{verbatim}(siehe ./src/task3.1/my_module_tb.sv)\end{verbatim}

\item Visualize the resulting waveforms.

\begin{verbatim}(siehe ./src/task3.1/my_module_tb_waveform.png)\end{verbatim}
\end{enumerate}

\subsection{Full Adder}

\textbf{Tasks}

\begin{enumerate}
\item Implement the module \texttt{full\_adder}. Exclusively use gate-level primitives in your design.

\begin{verbatim}(siehe ./src/task3.2/full_adder.sv)\end{verbatim}

\item Test your implementation in the testbench \texttt{full\_adder\_tb}. Your testbench should check the outputs for all possible inputs (see Table 3.2.1) through \texttt{assert()} statements.

\begin{verbatim}(siehe ./src/task3.2/full_adder_tb.sv)\end{verbatim}

\item Visualize the waveform generated by your module. Only show \texttt{i\_a}, \texttt{i\_b}, \texttt{i\_carry\_in}, \texttt{o\_s} and \texttt{o\_carry\_out} of the \texttt{full\_adder} module in that order.

\begin{verbatim}(siehe ./src/task3.2/full_adder_tb_waveform.png)\end{verbatim}
\end{enumerate}

\subsection{Four-bit Ripple-Carry Adder}

\textbf{Tasks}

\begin{enumerate}
\item Draw the schematic of the four-bit ripple-carry adder as a sequence of full adders.

\textbf{Schaltbild des 4-Bit Ripple-Carry Adders:}

Der 4-Bit Ripple-Carry Adder besteht aus vier kaskadierten Volladdierern (FA). Jeder Volladdierer addiert zwei Eingangsbits ($A_i$ und $B_i$) sowie den Carry-Eingang ($C_i$) und erzeugt ein Summenbit ($S_i$) sowie einen Carry-Ausgang, der zum nächsten Volladdierer weitergeleitet wird.

\begin{center}
\includegraphics[width=0.8\textwidth]{ripple_carry_adder.png}
\end{center}

\item Derive the total number of possible inputs for the four-bit ripple-carry adder! How would this change if we were to implement a 32-bit ripple-carry adder?

\textbf{Anzahl möglicher Eingangskombinationen:}

Der 4-Bit Ripple-Carry Adder hat folgende Eingänge:
\begin{itemize}
    \item $A_{[3:0]}$: 4 Bits
    \item $B_{[3:0]}$: 4 Bits
    \item $C_{in}$: 1 Bit
\end{itemize}

\noindent
Insgesamt: $4 + 4 + 1 = 9$ Eingangsbits.

\noindent
Gesamtzahl möglicher Eingangskombinationen:
\begin{align*}
    N_4 = 2^9 = 512
\end{align*}

\noindent
\textbf{Für einen 32-Bit Ripple-Carry Adder:}

Eingänge: $32 + 32 + 1 = 65$ Bits.

\noindent
Gesamtzahl möglicher Eingangskombinationen:
\begin{align*}
    N_{32} = 2^{65} \approx 3{,}69 \times 10^{19}
\end{align*}

\item Complete Table 3.3.1!

\textbf{Vervollständigte Wahrheitstabelle:}

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
    \hline
    $A_{[3:0]}$ & $B_{[3:0]}$ & $C_{in}$ & $S_{[3:0]}$ & $C_{out}$ \\
    \hline
    0000 & 0000 & 0 & 0000 & 0 \\
    \hline
    1010 & 0001 & 0 & 1011 & 0 \\
    \hline
    1100 & 0000 & 1 & 1101 & 0 \\
    \hline
    0101 & 1010 & 1 & 0000 & 1 \\
    \hline
    0111 & 1100 & 0 & 0011 & 1 \\
    \hline
    1111 & 1111 & 1 & 1111 & 1 \\
    \hline
\end{tabular}
\end{center}

\item Implement the module \texttt{ripple\_carry\_adder\_4} by completing the module in Listing 3.3.1.

\begin{verbatim}(siehe ./src/task3.3/ripple_carry_adder_4.sv)\end{verbatim}

\item Test your implementation in the testbench \texttt{ripple\_carry\_adder\_4\_tb} by completing the module in Listing 3.3.2. Your testbench should check the outputs for all inputs in Table 3.3.1 using \texttt{assert()} statements.

\begin{verbatim}(siehe ./src/task3.3/ripple_carry_adder_4_tb.sv)\end{verbatim}

\item Visualize the waveform generated by your module for Table 3.3.1's inputs. Only show the four-bit inputs \texttt{i\_a}, \texttt{i\_b}, the carry in \texttt{i\_carry\_in}, the four-bit output \texttt{o\_s} and the carry out \texttt{o\_carry\_out} of the \texttt{ripple\_carry\_adder\_4} module in that order.

\begin{verbatim}(siehe ./src/task3.3/ripple_carry_adder_4_tb_waveform.png)\end{verbatim}
\end{enumerate}

\subsection{Carry-Lookahead Adder}

\textbf{Tasks}

\begin{enumerate}
\item Implement \texttt{cla\_pre\_4} (Fig. 3.4.1) and test with \texttt{cla\_pre\_4\_tb}.

\begin{verbatim}(siehe ./src/task3.4/cla_pre_4/cla_pre_4.sv)\end{verbatim}
\begin{verbatim}(siehe ./src/task3.4/cla_pre_4/cla_pre_4_tb.sv)\end{verbatim}

\item Implement \texttt{cla\_logic\_4} (Fig. 3.4.2) and test with \texttt{cla\_logic\_4\_tb}.

\begin{verbatim}(siehe ./src/task3.4/cla_logic_4/cla_logic_4.sv)\end{verbatim}
\begin{verbatim}(siehe ./src/task3.4/cla_pre_4/cla_logic_4_tb.sv)\end{verbatim}

\item Implement the 4-bit carry-lookahead block \texttt{cla\_block\_4} (Fig. 3.4.3). Use the two modules \texttt{cla\_pre\_4} and \texttt{cla\_logic\_4} in your design. Use the testbench \texttt{cla\_block\_4\_tb} for your tests.

\begin{verbatim}(siehe ./src/task3.4/cla_block_4/cla_block_4.sv)\end{verbatim}
\begin{verbatim}(siehe ./src/task3.4/cla_block_4/cla_block_4_tb.sv)\end{verbatim}

\item Implement a 64-bit carry-lookahead adder by chaining sixteen 4-bit carry-lookahead blocks (Fig. 3.4.4). Use the testbench \texttt{cla\_adder\_64\_tb}.

\begin{verbatim}(siehe ./src/task3.4/cla_adder_64/cla_adder_64.sv)\end{verbatim}
\begin{verbatim}(siehe ./src/task3.4/cla_adder_64/cla_adder_64_tb.sv)\end{verbatim}
\end{enumerate}

\subsection{Delays}

\textbf{Tasks}

\begin{enumerate}
\item Implement the circuit shown in Fig. 3.5.1 in SystemVerilog using gate-level primitives. Save as \texttt{module\_with\_delays.sv}. Add delays to your circuit.

\begin{verbatim}(siehe ./src/task3.5/module_with_delays.sv)\end{verbatim}

\item Demonstrate the behavior with a testbench \texttt{module\_with\_delays\_tb.sv}. Show that a glitch appears when changing the inputs from $(A,B,C) = (1,1,1)$ to $(A,B,C) = (1,1,0)$. Visualize the obtained waveforms.

\begin{verbatim}(siehe ./src/task3.5/module_with_delays_tb.sv)\end{verbatim}
\begin{verbatim}(siehe ./src/task3.5/module_with_delays_tb_waveform.png)\end{verbatim}
\end{enumerate}

\end{document}
\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{tikz}
\usepackage{circuitikz}
\geometry{margin=1.5cm}

\title{Computer Engineering -- Submission due 03.11.2020}
\author{Jan Vogt, Yannik Köllmann - in gleichen Teilen}
\date{\today}

\begin{document}

    \maketitle

    \section{Gate-level Modeling}

    \subsection{My First Module}

    \subsubsection{Task 1: Implementation}
    
    \textbf{Aufgabe:} Implement Eq. (3.1.1) in a module named my\_module using gate-level primitives.
    
    \begin{verbatim}(siehe ./src/task3.1.1/my_module.sv)\end{verbatim}

    \subsubsection{Task 2: Testbench}
    
    \textbf{Aufgabe:} Test your implementation using the testbench my\_module\_tb.
    
    \begin{verbatim}(siehe ./src/task3.1.2/my_module_tb.sv)\end{verbatim}

    \subsubsection{Task 3: Waveform Visualization}
    
    \textbf{Aufgabe:} Visualize the resulting waveforms.
    
    \begin{verbatim}(siehe ./src/task3.1.3/waveform.png)\end{verbatim}

    \subsection{Full Adder}

    \subsubsection{Task 1: Implementation}
    
    \textbf{Aufgabe:} Implement the module full\_adder. Exclusively use gate-level primitives in your design.
    
    \begin{verbatim}(siehe ./src/task3.2.1/full_adder.sv)\end{verbatim}

    \subsubsection{Task 2: Testbench}
    
    \textbf{Aufgabe:} Test your implementation in the testbench full\_adder\_tb. Your testbench should check the outputs for all possible inputs through assert() statements.
    
    \begin{verbatim}(siehe ./src/task3.2.2/full_adder_tb.sv)\end{verbatim}

    \subsubsection{Task 3: Waveform Visualization}
    
    \textbf{Aufgabe:} Visualize the waveform generated by your module. Only show i\_a, i\_b, i\_carry\_in, o\_s and o\_carry\_out of the full\_adder module in that order.
    
    \begin{verbatim}(siehe ./src/task3.2.3/waveform.png)\end{verbatim}

    \subsection{Four-bit Ripple-Carry Adder}

    \subsubsection{Task 1: Schematic}

    \textbf{Aufgabe:} Draw the schematic of the four-bit ripple-carry adder as a sequence of full adders.

    Das Schaltbild des 4-Bit Ripple-Carry Adders als Sequenz von Volladdierern ist in Abbildung \ref{fig:ripple_carry} dargestellt.

    \begin{figure}[h]
        \centering
        \begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
            % Full Adder 0
            \draw (0,0) rectangle (2,2);
            \node at (1,1) {FA};
            \node[above] at (0.5,2) {$A_0$};
            \node[above] at (1.5,2) {$B_0$};
            \node[left] at (0,1) {$C_{in}$};
            \node[below] at (0.5,0) {$S_0$};
            \node[right] at (2,1) {$C_0$};
            
            % Arrows FA0
            \draw[->] (0.5,2.3) -- (0.5,2);
            \draw[->] (1.5,2.3) -- (1.5,2);
            \draw[->] (-0.3,1) -- (0,1);
            \draw[->] (0.5,0) -- (0.5,-0.3);
            
            % Full Adder 1
            \draw (3,0) rectangle (5,2);
            \node at (4,1) {FA};
            \node[above] at (3.5,2) {$A_1$};
            \node[above] at (4.5,2) {$B_1$};
            \node[left] at (3,1) {$C_0$};
            \node[below] at (3.5,0) {$S_1$};
            \node[right] at (5,1) {$C_1$};
            
            % Arrows FA1
            \draw[->] (3.5,2.3) -- (3.5,2);
            \draw[->] (4.5,2.3) -- (4.5,2);
            \draw[->] (2,1) -- (3,1);
            \draw[->] (3.5,0) -- (3.5,-0.3);
            
            % Full Adder 2
            \draw (6,0) rectangle (8,2);
            \node at (7,1) {FA};
            \node[above] at (6.5,2) {$A_2$};
            \node[above] at (7.5,2) {$B_2$};
            \node[left] at (6,1) {$C_1$};
            \node[below] at (6.5,0) {$S_2$};
            \node[right] at (8,1) {$C_2$};
            
            % Arrows FA2
            \draw[->] (6.5,2.3) -- (6.5,2);
            \draw[->] (7.5,2.3) -- (7.5,2);
            \draw[->] (5,1) -- (6,1);
            \draw[->] (6.5,0) -- (6.5,-0.3);
            
            % Full Adder 3
            \draw (9,0) rectangle (11,2);
            \node at (10,1) {FA};
            \node[above] at (9.5,2) {$A_3$};
            \node[above] at (10.5,2) {$B_3$};
            \node[left] at (9,1) {$C_2$};
            \node[below] at (9.5,0) {$S_3$};
            \node[right] at (11,1) {$C_{out}$};
            
            % Arrows FA3
            \draw[->] (9.5,2.3) -- (9.5,2);
            \draw[->] (10.5,2.3) -- (10.5,2);
            \draw[->] (8,1) -- (9,1);
            \draw[->] (9.5,0) -- (9.5,-0.3);
            \draw[->] (11,1) -- (11.3,1);
        \end{tikzpicture}
        \caption{4-Bit Ripple-Carry Adder als Sequenz von vier Volladdierern. Der Carry ripple durch die Kette der Volladdierer.}
        \label{fig:ripple_carry}
    \end{figure}

    \noindent
    Der 4-Bit Ripple-Carry Adder besteht aus vier kaskadierten Volladdierern (FA). Jeder Volladdierer addiert zwei Eingangsbits ($A_i$ und $B_i$) sowie den Carry-Eingang ($C_i$) und erzeugt ein Summenbit ($S_i$) sowie einen Carry-Ausgang ($C_i$), der zum nächsten Volladdierer weitergeleitet wird.

    \subsubsection{Task 2: Number of Possible Inputs}

    \textbf{Aufgabe:} Derive the total number of possible inputs for the four-bit ripple-carry adder! How would this change if we were to implement a 32-bit ripple-carry adder?

    \textbf{Für den 4-Bit Ripple-Carry Adder:}

    Der 4-Bit Ripple-Carry Adder hat folgende Eingänge:
    \begin{itemize}
        \item $A_{[3:0]}$: 4 Bits
        \item $B_{[3:0]}$: 4 Bits
        \item $C_{in}$: 1 Bit
    \end{itemize}

    \noindent
    Insgesamt haben wir also $4 + 4 + 1 = 9$ Eingangsbits.

    \noindent
    Die Gesamtzahl möglicher Eingangskombinationen ist:
    \begin{align*}
        N_4 = 2^9 = 512
    \end{align*}

    \textbf{Für einen 32-Bit Ripple-Carry Adder:}

    Ein 32-Bit Ripple-Carry Adder hätte folgende Eingänge:
    \begin{itemize}
        \item $A_{[31:0]}$: 32 Bits
        \item $B_{[31:0]}$: 32 Bits
        \item $C_{in}$: 1 Bit
    \end{itemize}

    \noindent
    Insgesamt: $32 + 32 + 1 = 65$ Eingangsbits.

    \noindent
    Die Gesamtzahl möglicher Eingangskombinationen wäre:
    \begin{align*}
        N_{32} = 2^{65} = 36\,893\,488\,147\,419\,103\,232 \approx 3{,}69 \times 10^{19}
    \end{align*}

    \noindent
    Dies ist eine astronomisch große Zahl, was zeigt, dass eine vollständige Testabdeckung aller Eingangskombinationen praktisch unmöglich ist.

    \subsubsection{Task 3: Complete Truth Table}

    \textbf{Aufgabe:} Complete Table 3.3.1!

    Tabelle \ref{tab:truth_table} zeigt die vervollständigte Wahrheitstabelle für den 4-Bit Ripple-Carry Adder.

    \begin{table}[h]
        \centering
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            $A_{[3:0]}$ & $B_{[3:0]}$ & $C_{in}$ & $S_{[3:0]}$ & $C_{out}$ \\
            \hline
            0000 & 0000 & 0 & 0000 & 0 \\
            \hline
            1010 & 0001 & 0 & 1011 & 0 \\
            \hline
            1100 & 0000 & 1 & 1101 & 0 \\
            \hline
            0101 & 1010 & 1 & 0000 & 1 \\
            \hline
            0111 & 1100 & 0 & 0011 & 1 \\
            \hline
            1111 & 1111 & 1 & 1111 & 1 \\
            \hline
        \end{tabular}
        \caption{Vervollständigte Wahrheitstabelle des 4-Bit Ripple-Carry Adders}
        \label{tab:truth_table}
    \end{table}

    \noindent
    \textbf{Berechnungen für die fehlenden Einträge:}

    \begin{enumerate}
        \item \textbf{Zeile 3:} $1100_2 + 0000_2 + 1 = 12 + 0 + 1 = 13 = 1101_2$, kein Carry
        
        \item \textbf{Zeile 4:} $0101_2 + 1010_2 + 1 = 5 + 10 + 1 = 16 = 10000_2$
        
        Dies ergibt $S_{[3:0]} = 0000_2$ und $C_{out} = 1$
        
        \item \textbf{Zeile 5:} $0111_2 + 1100_2 + 0 = 7 + 12 + 0 = 19 = 10011_2$
        
        Dies ergibt $S_{[3:0]} = 0011_2$ und $C_{out} = 1$
        
        \item \textbf{Zeile 6:} $1111_2 + 1111_2 + 1 = 15 + 15 + 1 = 31 = 11111_2$
        
        Dies ergibt $S_{[3:0]} = 1111_2$ und $C_{out} = 1$
    \end{enumerate}

    \subsubsection{Task 4: Implementation}
    
    \textbf{Aufgabe:} Implement the module ripple\_carry\_adder\_4 by completing the module in Listing 3.3.1.
    
    \begin{verbatim}(siehe ./src/task3.3.4/ripple_carry_adder_4.sv)\end{verbatim}

    \subsubsection{Task 5: Testbench}
    
    \textbf{Aufgabe:} Test your implementation in the testbench ripple\_carry\_adder\_4\_tb by completing the module in Listing 3.3.2. Your testbench should check the outputs for all inputs in Table 3.3.1 using assert() statements.
    
    \begin{verbatim}(siehe ./src/task3.3.5/ripple_carry_adder_4_tb.sv)\end{verbatim}

    \subsubsection{Task 6: Waveform Visualization}
    
    \textbf{Aufgabe:} Visualize the waveform generated by your module for Table 3.3.1's inputs. Only show the four-bit inputs i\_a, i\_b, the carry in i\_carry\_in, the four-bit output o\_s and the carry out o\_carry\_out of the ripple\_carry\_adder\_4 module in that order.
    
    \begin{verbatim}(siehe ./src/task3.3.6/waveform.png)\end{verbatim}

    \subsection{Carry-Lookahead Adder}

    \subsubsection{Task 1: cla\_pre\_4}
    
    \textbf{Aufgabe:} Implement cla\_pre\_4 (Fig. 3.4.1) and test with cla\_pre\_4\_tb.
    
    \textbf{Implementation:}
    \begin{verbatim}(siehe ./src/task3.4.1/cla_pre_4.sv)\end{verbatim}
    
    \textbf{Testbench:}
    \begin{verbatim}(siehe ./src/task3.4.1/cla_pre_4_tb.sv)\end{verbatim}

    \subsubsection{Task 2: cla\_logic\_4}
    
    \textbf{Aufgabe:} Implement cla\_logic\_4 (Fig. 3.4.2) and test with cla\_logic\_4\_tb.
    
    \textbf{Implementation:}
    \begin{verbatim}(siehe ./src/task3.4.2/cla_logic_4.sv)\end{verbatim}
    
    \textbf{Testbench:}
    \begin{verbatim}(siehe ./src/task3.4.2/cla_logic_4_tb.sv)\end{verbatim}

    \subsubsection{Task 3: cla\_block\_4}
    
    \textbf{Aufgabe:} Implement the 4-bit carry-lookahead block cla\_block\_4 (Fig. 3.4.3). Use the two modules cla\_pre\_4 and cla\_logic\_4 in your design. Use the testbench cla\_block\_4\_tb for your tests.
    
    \textbf{Implementation:}
    \begin{verbatim}(siehe ./src/task3.4.3/cla_block_4.sv)\end{verbatim}
    
    \textbf{Testbench:}
    \begin{verbatim}(siehe ./src/task3.4.3/cla_block_4_tb.sv)\end{verbatim}

    \subsubsection{Task 4: cla\_adder\_64}
    
    \textbf{Aufgabe:} Implement a 64-bit carry-lookahead adder by chaining sixteen 4-bit carry-lookahead blocks (Fig. 3.4.4). Use the testbench cla\_adder\_64\_tb.
    
    \textbf{Implementation:}
    \begin{verbatim}(siehe ./src/task3.4.4/cla_adder_64.sv)\end{verbatim}
    
    \textbf{Testbench:}
    \begin{verbatim}(siehe ./src/task3.4.4/cla_adder_64_tb.sv)\end{verbatim}

    \subsection{Delays}

    \subsubsection{Task 1: Implementation with Delays}
    
    \textbf{Aufgabe:} Implement the circuit shown in Fig. 3.5.1 in SystemVerilog using gate-level primitives. Save as module\_with\_delays.sv. Add delays to your circuit.
    
    \begin{verbatim}(siehe ./src/task3.5.1/module_with_delays.sv)\end{verbatim}

    \subsubsection{Task 2: Glitch Demonstration}
    
    \textbf{Aufgabe:} Demonstrate the behavior with a testbench module\_with\_delays\_tb.sv. Show that a glitch appears when changing the inputs from $(A,B,C) = (1,1,1)$ to $(A,B,C) = (1,1,0)$. Visualize the obtained waveforms.
    
    \textbf{Testbench:}
    \begin{verbatim}(siehe ./src/task3.5.2/module_with_delays_tb.sv)\end{verbatim}
    
    \textbf{Waveform:}
    \begin{verbatim}(siehe ./src/task3.5.2/waveform.png)\end{verbatim}

\end{document}
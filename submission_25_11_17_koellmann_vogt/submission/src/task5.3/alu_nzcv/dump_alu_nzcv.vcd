$date
	Thu Nov 13 17:01:15 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module alu_nzcv_tb $end
$var wire 32 ! l_result [31:0] $end
$var wire 4 " l_nzcv [3:0] $end
$var parameter 32 # N $end
$var reg 32 $ l_a [31:0] $end
$var reg 2 % l_alu_ctrl [1:0] $end
$var reg 32 & l_b [31:0] $end
$scope module dut $end
$var wire 32 ' i_a [31:0] $end
$var wire 2 ( i_alu_ctrl [1:0] $end
$var wire 32 ) i_b [31:0] $end
$var wire 32 * l_and [31:0] $end
$var wire 32 + l_or [31:0] $end
$var wire 32 , o_result [31:0] $end
$var wire 4 - o_nzcv [3:0] $end
$var wire 1 . l_same_sign $end
$var wire 32 / l_mux_2_result [31:0] $end
$var wire 1 0 l_carry_out $end
$var wire 32 1 l_adder_result [31:0] $end
$var parameter 32 2 N $end
$scope module adder_inst $end
$var wire 32 3 i_a [31:0] $end
$var wire 1 4 i_carry_in $end
$var wire 32 5 o_s [31:0] $end
$var wire 1 0 o_carry_out $end
$var wire 32 6 i_b [31:0] $end
$var parameter 32 7 N $end
$upscope $end
$scope module mux_2_inst $end
$var wire 32 8 i_in0 [31:0] $end
$var wire 32 9 i_in1 [31:0] $end
$var wire 1 : i_s $end
$var wire 32 ; o_out [31:0] $end
$var parameter 32 < N $end
$upscope $end
$scope module mux_4_inst $end
$var wire 32 = i_in0 [31:0] $end
$var wire 32 > i_in1 [31:0] $end
$var wire 32 ? i_in2 [31:0] $end
$var wire 32 @ i_in3 [31:0] $end
$var wire 2 A i_s [1:0] $end
$var wire 32 B o_out [31:0] $end
$var wire 32 C l_mux_low [31:0] $end
$var wire 32 D l_mux_high [31:0] $end
$var parameter 32 E N $end
$scope module mux_final $end
$var wire 1 F i_s $end
$var wire 32 G o_out [31:0] $end
$var wire 32 H i_in1 [31:0] $end
$var wire 32 I i_in0 [31:0] $end
$var parameter 32 J N $end
$upscope $end
$scope module mux_high $end
$var wire 32 K i_in0 [31:0] $end
$var wire 32 L i_in1 [31:0] $end
$var wire 1 M i_s $end
$var wire 32 N o_out [31:0] $end
$var parameter 32 O N $end
$upscope $end
$scope module mux_low $end
$var wire 32 P i_in0 [31:0] $end
$var wire 32 Q i_in1 [31:0] $end
$var wire 1 R i_s $end
$var wire 32 S o_out [31:0] $end
$var parameter 32 T N $end
$upscope $end
$upscope $end
$scope module xor_3_inst $end
$var wire 1 U i_in0 $end
$var wire 1 V i_in1 $end
$var wire 1 W i_in2 $end
$var wire 1 . o_res $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 T
b100000 O
b100000 J
b100000 E
b100000 <
b100000 7
b100000 2
b100000 #
$end
#0
$dumpvars
0W
0V
0U
b0 S
0R
b0 Q
b0 P
b0 N
0M
b0 L
b0 K
b0 I
b0 H
b0 G
0F
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 ;
0:
b11111111111111111111111111111111 9
b0 8
b0 6
b0 5
04
b0 3
b0 1
00
b0 /
0.
b100 -
b0 ,
b0 +
b0 *
b0 )
b0 (
b0 '
b0 &
b0 %
b0 $
b100 "
b0 !
$end
#10
b1000 "
b1000 -
b11111111111111111111111111111111 !
b11111111111111111111111111111111 ,
b11111111111111111111111111111111 B
b11111111111111111111111111111111 G
1.
b11111111111111111111111111111111 C
b11111111111111111111111111111111 I
b11111111111111111111111111111111 S
b11111111111111111111111111111111 1
b11111111111111111111111111111111 5
b11111111111111111111111111111111 =
b11111111111111111111111111111111 >
b11111111111111111111111111111111 P
b11111111111111111111111111111111 Q
b11111111111111111111111111111111 +
b11111111111111111111111111111111 @
b11111111111111111111111111111111 L
b0 9
1V
b11111111111111111111111111111111 /
b11111111111111111111111111111111 6
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 &
b11111111111111111111111111111111 )
b11111111111111111111111111111111 8
#20
b0 !
b0 ,
b0 B
b0 G
b1 D
b1 H
b1 N
b0 C
b0 I
b0 S
b110 "
b110 -
b1 *
b1 ?
b1 K
b0 1
b0 5
b0 =
b0 >
b0 P
b0 Q
10
b1 $
b1 '
b1 3
#30
0.
b0 "
b0 -
b10000000000000000 !
b10000000000000000 ,
b10000000000000000 B
b10000000000000000 G
00
b10000000000000000 C
b10000000000000000 I
b10000000000000000 S
b11111111111111111111111111111110 9
0V
b1 /
b1 6
b1 ;
b1111111111111111 +
b1111111111111111 @
b1111111111111111 L
b10000000000000000 1
b10000000000000000 5
b10000000000000000 =
b10000000000000000 >
b10000000000000000 P
b10000000000000000 Q
b1 &
b1 )
b1 8
b1111111111111111 $
b1111111111111111 '
b1111111111111111 3
#40
b110 "
b110 -
10
b0 !
b0 ,
b0 B
b0 G
1.
b0 D
b0 H
b0 N
b0 C
b0 I
b0 S
1:
14
1W
1R
1M
b11111111111111111111111111111111 9
b11111111111111111111111111111111 /
b11111111111111111111111111111111 6
b11111111111111111111111111111111 ;
b0 +
b0 @
b0 L
b0 *
b0 ?
b0 K
b0 1
b0 5
b0 =
b0 >
b0 P
b0 Q
b1 %
b1 (
b1 A
b0 &
b0 )
b0 8
b0 $
b0 '
b0 3
#50
b10 "
b10 -
b1111111111111111 !
b1111111111111111 ,
b1111111111111111 B
b1111111111111111 G
b11111111111111111111111111111110 /
b11111111111111111111111111111110 6
b11111111111111111111111111111110 ;
b10000000000000001 D
b10000000000000001 H
b10000000000000001 N
b1111111111111111 C
b1111111111111111 I
b1111111111111111 S
b11111111111111111111111111111110 9
b10000000000000001 +
b10000000000000001 @
b10000000000000001 L
b1111111111111111 1
b1111111111111111 5
b1111111111111111 =
b1111111111111111 >
b1111111111111111 P
b1111111111111111 Q
b1 &
b1 )
b1 8
b10000000000000000 $
b10000000000000000 '
b10000000000000000 3
#60
b1000 "
b1000 -
0.
b11111111111111111111111111111111 !
b11111111111111111111111111111111 ,
b11111111111111111111111111111111 B
b11111111111111111111111111111111 G
b11111111111111111111111111111111 /
b11111111111111111111111111111111 6
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 D
b11111111111111111111111111111111 H
b11111111111111111111111111111111 N
b11111111111111111111111111111110 C
b11111111111111111111111111111110 I
b11111111111111111111111111111110 S
0:
04
0W
0R
0M
1F
b0 9
1V
b11111111111111111111111111111111 +
b11111111111111111111111111111111 @
b11111111111111111111111111111111 L
b11111111111111111111111111111111 *
b11111111111111111111111111111111 ?
b11111111111111111111111111111111 K
1U
b11111111111111111111111111111110 1
b11111111111111111111111111111110 5
b11111111111111111111111111111110 =
b11111111111111111111111111111110 >
b11111111111111111111111111111110 P
b11111111111111111111111111111110 Q
b10 %
b10 (
b10 A
b11111111111111111111111111111111 &
b11111111111111111111111111111111 )
b11111111111111111111111111111111 8
b11111111111111111111111111111111 $
b11111111111111111111111111111111 '
b11111111111111111111111111111111 3
#70
b0 "
b0 -
b1110111010000110011010001110111 !
b1110111010000110011010001110111 ,
b1110111010000110011010001110111 B
b1110111010000110011010001110111 G
1.
b1110111010000110011010001110110 C
b1110111010000110011010001110110 I
b1110111010000110011010001110110 S
b1110111010000110011010001110111 D
b1110111010000110011010001110111 H
b1110111010000110011010001110111 N
b1110111010000110011010001110110 1
b1110111010000110011010001110110 5
b1110111010000110011010001110110 =
b1110111010000110011010001110110 >
b1110111010000110011010001110110 P
b1110111010000110011010001110110 Q
b1110111010000110011010001110111 *
b1110111010000110011010001110111 ?
b1110111010000110011010001110111 K
b10001000101111001100101110001000 9
0V
b1110111010000110011010001110111 /
b1110111010000110011010001110111 6
b1110111010000110011010001110111 ;
b1110111010000110011010001110111 &
b1110111010000110011010001110111 )
b1110111010000110011010001110111 8
#80
b100 "
b100 -
b0 !
b0 ,
b0 B
b0 G
b0 D
b0 H
b0 N
b11111111111111111111111111111111 C
b11111111111111111111111111111111 I
b11111111111111111111111111111111 S
b0 9
1V
b11111111111111111111111111111111 /
b11111111111111111111111111111111 6
b11111111111111111111111111111111 ;
b0 *
b0 ?
b0 K
0U
b11111111111111111111111111111111 1
b11111111111111111111111111111111 5
b11111111111111111111111111111111 =
b11111111111111111111111111111111 >
b11111111111111111111111111111111 P
b11111111111111111111111111111111 Q
00
b11111111111111111111111111111111 &
b11111111111111111111111111111111 )
b11111111111111111111111111111111 8
b0 $
b0 '
b0 3
#90
b1000 "
b1000 -
b1 C
b1 I
b1 S
b11111111111111111111111111111111 !
b11111111111111111111111111111111 ,
b11111111111111111111111111111111 B
b11111111111111111111111111111111 G
b0 /
b0 6
b0 ;
b1 1
b1 5
b1 =
b1 >
b1 P
b1 Q
00
0.
b11111111111111111111111111111111 D
b11111111111111111111111111111111 H
b11111111111111111111111111111111 N
1:
14
1W
1R
1M
b11 %
b11 (
b11 A
#100
